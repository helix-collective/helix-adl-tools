import * as adlast from "./adl-gen/sys/adlast";
import { Command } from "commander";
import {
  collect,
  forEachDecl,
  parseAdl,
  scopedName,
  getAnnotation,
  LoadedAdl,
} from "./util";

import { ImportingHelper } from "./ts-services/import-helper";
import {
  IndentableWriter,
  writeNativeBridge,
  writeTypeScriptBridge,
} from "./react-native/react-native-utils";

export interface RNBridge {
  scopedDecl: adlast.ScopedDecl;
  struct: adlast.DeclType_Struct_;
  ann: {} | null;
  name: string;
}

export interface BridgingReqRes {
  scopedDecl: adlast.ScopedDecl;
  struct: adlast.DeclType_Struct_;
  ann: {} | null;
  name: string;
}

export function configureCli(program: Command) {
  program
    .command("java-rnmodule [adlFiles...]")
    .description("Generate Java mobile code for react-native bridging modules")
    .option("-I, --searchdir <path>", "Add to adl searchpath", collect, [])
    .option("--javadir <path>", "where the resulting java files end up")
    .option("--tsdir <path>", "where the resulting typescript files end up")
    .option(
      "--package <package>",
      "The package into which the generated adl is placed",
      "adl"
    )
    .action((adlFiles: string[], cmd) => {
      const adlSearchPath: string[] = cmd["searchdir"];
      const javaOutdir: string = cmd["javadir"];
      const tsOutdir: string = cmd["tsdir"];
      const packageName: string = cmd["package"];

      const nativeBridges: RNBridge[] = [];

      (async () => {
        const loadedAdl = await parseAdl(adlFiles, adlSearchPath);

        // Collect all the native bridges that have been annotated
        forEachDecl(loadedAdl.modules, (scopedDecl) => {
          if (scopedDecl.decl.type_.kind == "struct_") {
            const struct = scopedDecl.decl.type_;
            const ann = getAnnotation(scopedDecl.decl.annotations, RN_BRIDGE);
            if (ann != undefined) {
              const name = getModuleName(scopedDecl);
              nativeBridges.push({ scopedDecl, struct, ann, name });
            }
          }
        });
        nativeBridges.sort((t1, t2) =>
          t1.name < t2.name ? -1 : t1.name > t2.name ? 1 : 0
        );

        // Write Java Native bridge
        nativeBridges.forEach((b) =>
          writeNativeBridge(b, {
            outdir: javaOutdir,
            nativeBridges,
            packageName,
            loadedAdl,
          })
        );

        // Write Typescript Bridges
        nativeBridges.forEach((b) =>
          writeTypeScriptBridge(b, {
            outdir: tsOutdir,
            nativeBridges,
            packageName,
            loadedAdl,
          })
        );

        nativeBridges.forEach((nativeBridge) => {
          const writer = new IndentableWriter(
            "/dev/null"
            // outdir + "/" + nativeBridge.name + ".ts"
          );
          const importHelper = new ImportingHelper();

          writer.writeLn(`// Class autogenerated by adl for native bridge`);

          writer.writeLn(`import { NativeModules } from "react-native";`);
          writer.writeLn(`const { ${nativeBridge.name} } = NativeModules;`);
          writer.blankLn();

          const writeReqResInterface = (obj: BridgingReqRes) => {
            writer.writeLn(`export interface ${obj.name} {`);
            writer.indent();

            obj.struct.value.fields.forEach((field) => {
              if (field.typeExpr.typeRef.kind === "primitive") {
                writer.writeLn(
                  `${field.name}: ${importHelper.asReferencedName(
                    field.typeExpr
                  )};`
                );
              } else if (field.typeExpr.typeRef.kind === "reference") {
                writer.writeLn(
                  `${field.name}: ${field.typeExpr.typeRef.value.name}`
                );
              }
            });

            writer.unindent();
            writer.writeLn("}");

            writer.blankLn();
          };

          // classesToImport.forEach(writeReqResInterface);

          // Typescript: the raw interface
          writer.writeLn(`interface ${nativeBridge.name}BridgeRaw {`);
          writer.indent();

          const flattenType = (
            adlTree: LoadedAdl,
            moduleName: string,
            prefix: string = ""
          ): string => {
            let result = "";

            const sDecl = adlTree.allAdlDecls[moduleName];
            if (sDecl.decl.type_.kind === "struct_") {
              const fields = sDecl.decl.type_.value.fields;
              fields.forEach((field) => {
                if (field.typeExpr.typeRef.kind === "primitive") {
                  result += `${prefix}${
                    field.name
                  }: ${importHelper.asReferencedName(field.typeExpr)}, `;
                }
                if (field.typeExpr.typeRef.kind === "reference") {
                  result +=
                    flattenType(
                      adlTree,
                      field.typeExpr.typeRef.value.moduleName +
                        "." +
                        field.typeExpr.typeRef.value.name,
                      prefix + field.name + "_"
                    ) + ",";
                }
                // console.log(field);
              });
            }

            result = result.trim();
            const trim = result.replace(/(^,)|(,$)/g, "");
            return trim;
          };

          const flattenCall = (
            adlTree: LoadedAdl,
            moduleName: string,
            prefix: string = ""
          ): string => {
            let result = "";

            const sDecl = adlTree.allAdlDecls[moduleName];
            if (sDecl.decl.type_.kind === "struct_") {
              const fields = sDecl.decl.type_.value.fields;
              fields.forEach((field) => {
                if (field.typeExpr.typeRef.kind === "primitive") {
                  result += `${prefix}${field.name}, `;
                }
                if (field.typeExpr.typeRef.kind === "reference") {
                  result +=
                    flattenCall(
                      adlTree,
                      field.typeExpr.typeRef.value.moduleName +
                        "." +
                        field.typeExpr.typeRef.value.name,
                      prefix + field.name + "."
                    ) + ",";
                }
                // console.log(field);
              });
            }

            result = result.trim();
            const trim = result.replace(/(^,)|(,$)/g, "");
            return trim;
          };

          const writeBridgingMethodFlat = (field: adlast.Field) => {
            writer.writeIndent();
            writer.writeRaw(`${field.name}: (`);

            const reqTypeExpr = field.typeExpr.parameters[0];
            if (
              reqTypeExpr.typeRef.kind === "primitive" &&
              reqTypeExpr.typeRef.value === "Void"
            ) {
            } else {
              if (reqTypeExpr.typeRef.kind === "primitive") {
                switch (reqTypeExpr.typeRef.value) {
                }
              } else if (reqTypeExpr.typeRef.kind === "reference") {
                writer.writeRaw(
                  flattenType(
                    loadedAdl,
                    reqTypeExpr.typeRef.value.moduleName +
                      "." +
                      reqTypeExpr.typeRef.value.name
                  )
                );
              }
            }

            const resTypeExpr = field.typeExpr.parameters[1];
            if (resTypeExpr.typeRef.kind === "primitive") {
              writer.writeRaw(
                `) => ${importHelper.asReferencedName(resTypeExpr)};\n`
              );
            } else if (resTypeExpr.typeRef.kind === "reference") {
              writer.writeRaw(`) => ${resTypeExpr.typeRef.value.name};\n`);
            }
          };

          const writeBridgingMethodCall = (field: adlast.Field) => {
            writer.writeIndent();

            const reqTypeExpr = field.typeExpr.parameters[0];
            if (
              reqTypeExpr.typeRef.kind === "primitive" &&
              reqTypeExpr.typeRef.value === "Void"
            ) {
            } else {
              if (reqTypeExpr.typeRef.kind === "primitive") {
                switch (reqTypeExpr.typeRef.value) {
                }
              } else if (reqTypeExpr.typeRef.kind === "reference") {
                writer.writeRaw(
                  flattenCall(
                    loadedAdl,
                    reqTypeExpr.typeRef.value.moduleName +
                      "." +
                      reqTypeExpr.typeRef.value.name,
                    "req."
                  )
                );
              }
            }
            writer.blankLn();
          };

          nativeBridge.struct.value.fields
            .filter((field) => field.typeExpr.typeRef.kind === "reference")
            .forEach(writeBridgingMethodFlat);

          writer.unindent();
          writer.writeLn("}");
          writer.blankLn();

          // write the usable class
          writer.writeLn(`export class ${nativeBridge.name}Bridge {`);
          writer.indent();

          writer.writeLn(
            `private bridge: ${nativeBridge.name}BridgeRaw = ${
              nativeBridge.name
            } as ${nativeBridge.name}BridgeRaw;`
          );

          const writeBridgingMethod = (field: adlast.Field) => {
            writer.writeIndent();
            writer.writeRaw(`${field.name} = (`);

            const reqTypeExpr = field.typeExpr.parameters[0];
            if (
              reqTypeExpr.typeRef.kind === "primitive" &&
              reqTypeExpr.typeRef.value === "Void"
            ) {
            } else {
              if (reqTypeExpr.typeRef.kind === "primitive") {
                writer.writeRaw(
                  `req: ${importHelper.asReferencedName(reqTypeExpr)}`
                );
              } else if (reqTypeExpr.typeRef.kind === "reference") {
                writer.writeRaw(`req: ${reqTypeExpr.typeRef.value.name}`);
              }
            }

            const resTypeExpr = field.typeExpr.parameters[1];
            if (resTypeExpr.typeRef.kind === "primitive") {
              writer.writeRaw(
                `): ${importHelper.asReferencedName(resTypeExpr)} => {\n`
              );
            } else if (resTypeExpr.typeRef.kind === "reference") {
              writer.writeRaw(`) => ${resTypeExpr.typeRef.value.name} => {\n`);
            }
            writer.indent();
            writer.writeIndent();
            writer.writeRaw(`return this.bridge.${field.name}(`);

            writeBridgingMethodCall(field);

            writer.writeRaw(");");
            writer.blankLn();
            writer.unindent();
            writer.writeLn("}");
          };

          nativeBridge.struct.value.fields
            .filter((field) => field.typeExpr.typeRef.kind === "reference")
            .forEach(writeBridgingMethod);

          writer.unindent();
          writer.writeLn("}");
          writer.blankLn();
        });
      })();
    });
}

function getModuleName(scopedDecl: adlast.ScopedDecl): string {
  const ann = getAnnotation(scopedDecl.decl.annotations, RN_BRIDGE);
  if (ann && typeof ann["moduleName"] == "string") {
    return ann["moduleName"];
  }
  return scopedDecl.decl.name;
}

const RN_MODULE = "onederful.mobile.reactnative";
const RN_BRIDGE = scopedName(RN_MODULE, "RnBridge");
const NATIVE_FUNCTION = scopedName(RN_MODULE, "NativeFunction");
const NATIVE_CALLBACK = scopedName(RN_MODULE, "NativeCallback");
