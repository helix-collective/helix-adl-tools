import * as fs from "fs";
import * as path from "path";
import * as adlast from "../adl-gen/sys/adlast";
import * as mkdirp from "mkdirp";
import { getAnnotation, LoadedAdl, scopedName } from "../util";
import { RNBridge } from "../gen-reactnativebridge";
import {
  getJavaFileName,
  writeAbstractImplementation,
  writeBridgingField,
} from "./java-helpers";
import _ from "lodash";
import {
  getDepFilename,
  getTsFileName,
  writeDep,
  writeTsBridges,
  writeTsInterface,
} from "./typescript-helpers";

// Scoped names of custom react-native types
export const RN_ADL_MODULE = "mobile.reactnative";
export const RN_MODULE = scopedName(RN_ADL_MODULE, "RnModule");
export const NATIVE_FUNCTION = scopedName(RN_ADL_MODULE, "NativeFunction");
export const NATIVE_CALLBACK = scopedName(RN_ADL_MODULE, "NativeCallback");

export const getModuleName = (scopedDecl: adlast.ScopedDecl): string => {
  const ann = getAnnotation(scopedDecl.decl.annotations, RN_MODULE);
  if (ann && typeof ann["moduleName"] == "string") {
    return ann["moduleName"];
  }
  return scopedDecl.decl.name;
};

// Utility class that helps write indented code blocks
export class IndentableWriter {
  constructor(
    outfile: string,
    private writer = fs.createWriteStream(outfile),
    private indentLevel = 0
  ) {}

  indent = () => {
    this.indentLevel += 1;
  };

  unindent = () => {
    this.indentLevel = Math.max(0, this.indentLevel - 1);
  };

  writeLn = (line: string) => {
    //todo this can be more elegant
    for (let i = 0; i < this.indentLevel; i++) {
      this.writer.write("  ");
    }
    this.writer.write(`${line}\n`);
  };

  writeIndent = () => {
    for (let i = 0; i < this.indentLevel; i++) {
      this.writer.write("  ");
    }
  };

  writeRaw = (str: string) => {
    this.writer.write(str);
  };

  blankLn = () => {
    this.writer.write("\n");
  };

  close = () => {
    this.writer.close();
  };
}

export const isNativeFunction = (field: adlast.Field): boolean => {
  return (
    field.typeExpr.typeRef.kind === "reference" &&
    field.typeExpr.typeRef.value.moduleName == NATIVE_FUNCTION.moduleName &&
    field.typeExpr.typeRef.value.name == NATIVE_FUNCTION.name
  );
};

export const isNativeCallback = (field: adlast.Field): boolean => {
  return (
    field.typeExpr.typeRef.kind === "reference" &&
    field.typeExpr.typeRef.value.moduleName == NATIVE_CALLBACK.moduleName &&
    field.typeExpr.typeRef.value.name == NATIVE_CALLBACK.name
  );
};

/**
 *
 * Returns all NativeFunctions and NativeCallbacks
 */
export const getBridgedMethods = (bridge: RNBridge): adlast.Field[] => {
  return bridge.struct.value.fields.filter(
    (field) => isNativeCallback(field) || isNativeFunction(field)
  );
};

export const getScopedName = (type: adlast.TypeExpr) => {
  if (type.typeRef.kind === "reference") {
    return type.typeRef.value.moduleName + "." + type.typeRef.value.name;
  }
  return "";
};

export const findUniqueImports = (bridge: RNBridge): adlast.TypeExpr[] => {
  const imports: adlast.TypeExpr[] = [];

  // TODO handle imports from different modules with same name
  const fields = getBridgedMethods(bridge);

  fields.forEach((field) => {
    const req = field.typeExpr.parameters[0];
    const res = field.typeExpr.parameters[1];

    if (!imports.find((i) => getScopedName(i) === getScopedName(req))) {
      if (req.typeRef.kind !== "primitive") imports.push(req);
    }

    if (!imports.find((i) => getScopedName(i) === getScopedName(res))) {
      if (res.typeRef.kind !== "primitive") {
        imports.push(res);
      }
    }
  });

  return imports;
};

export const writeNativeBridge = (
  nativeBridge: RNBridge,
  params: {
    outdir: string;
    nativeBridges: RNBridge[];
    packageName: string;
    loadedAdl: LoadedAdl;
  }
): void => {
  const { outdir, loadedAdl, nativeBridges, packageName } = params;

  const fileName = getJavaFileName(outdir, nativeBridge, packageName);
  const writer = new IndentableWriter(fileName);

  writer.writeLn(`// Class autogenerated by adl for native bridge`);
  writer.writeLn(
    `package ${packageName}.${nativeBridge.scopedDecl.moduleName};`
  );
  writer.blankLn();

  // import required adl types (if they are from a separate module)
  const imports = findUniqueImports(nativeBridge);
  imports
    .sort((t1, t2) =>
      getScopedName(t1) < getScopedName(t2)
        ? -1
        : getScopedName(t1) > getScopedName(t2)
        ? 1
        : 0
    )
    .filter((i) => {
      if (
        i.typeRef.kind === "reference" &&
        i.typeRef.value.moduleName === nativeBridge.scopedDecl.moduleName
      ) {
        return false;
      }
      return true;
    })
    .forEach((i) => {
      writer.writeLn(`import ${packageName}.${getScopedName(i)};`);
    });
  writer.blankLn();

  // import react-native requirements
  writer.writeLn("import com.facebook.react.bridge.Promise;");
  writer.writeLn(
    "import com.facebook.react.bridge.ReactContextBaseJavaModule;"
  );
  writer.writeLn("import com.facebook.react.bridge.ReactMethod;");
  writer.blankLn();

  writer.writeLn("import org.jetbrains.annotations.NotNull;");
  writer.blankLn();

  // ================ write class definition
  writer.writeLn(
    `public abstract class ${
      nativeBridge.name
    } extends ReactContextBaseJavaModule {`
  );

  // ================ class body
  writer.indent();
  nativeBridge.struct.value.fields
    .filter((field) => field.typeExpr.typeRef.kind === "reference")
    .forEach((field) => {
      writeBridgingField(field, writer); // write abstract bridging fields
      writeAbstractImplementation(field, writer); // write functions to map abstract flattened to adl objects
    });

  // write getName as a concrete method
  writer.writeLn(`@NotNull`);
  writer.writeLn(`@Override`);
  writer.writeLn(`public final String getName() {`);
  writer.indent();
  writer.writeLn(
    `// Overriding this function will prevent the generated typescript code from registering with the correct module`
  );
  writer.writeLn(`return "${nativeBridge.name}";`);
  writer.unindent();
  writer.writeLn(`}`);
  writer.blankLn();

  // close class
  writer.unindent();
  writer.writeLn("}");
  writer.close();
};

export const writeTypeScriptBridge = (
  nativeBridge: RNBridge,
  params: {
    outdir: string;
    nativeBridges: RNBridge[];
    packageName: string;
    loadedAdl: LoadedAdl;
  }
): void => {
  const { outdir, loadedAdl } = params;

  console.log("native bridge", nativeBridge.name);

  const filename = getTsFileName(outdir, nativeBridge);
  mkdirp.sync(path.dirname(filename));
  const writer = new IndentableWriter(filename);

  writer.writeLn(`// Class autogenerated by adl for native bridge`);
  writer.writeLn(`import { NativeModules } from "react-native";`);
  writer.writeLn(
    `const { ${nativeBridge.name}: NativeModule } = NativeModules;`
  );
  writer.blankLn();

  const imports = findUniqueImports(nativeBridge);
  imports
    .sort((t1, t2) =>
      getScopedName(t1) < getScopedName(t2)
        ? -1
        : getScopedName(t1) > getScopedName(t2)
        ? 1
        : 0
    )
    .forEach((i) => {
      // this can produce duplicated imports across files
      if (i.typeRef.kind === "reference") {
        const depFilename = getDepFilename(outdir, i.typeRef.value);
        mkdirp.sync(path.dirname(depFilename));
        const depWriter = new IndentableWriter(depFilename);

        writeDep(loadedAdl, i, depWriter, outdir, filename);

        // write the import into the file
        const file = path.relative(path.dirname(filename), depFilename);
        if (path.dirname(filename) === path.dirname(depFilename)) {
          writer.writeLn(
            `import { ${i.typeRef.value.name} } from './${file.substr(
              0,
              file.lastIndexOf(".")
            )}';`
          );
        } else {
          writer.writeLn(
            `import { ${i.typeRef.value.name} } from '${file.substr(
              0,
              file.lastIndexOf(".")
            )}';`
          );
        }
      }
    });
  writer.blankLn();

  writer.writeLn(`interface NativeInterface {`);
  writer.indent();

  nativeBridge.struct.value.fields
    .filter((field) => field.typeExpr.typeRef.kind === "reference")
    .forEach((field) => {
      writeTsInterface(field, writer); // write abstract bridging fields
    });

  writer.unindent();
  writer.writeLn("}");
  writer.blankLn();

  writer.writeLn(`class ${nativeBridge.name} {`);
  writer.indent();

  writer.writeLn(
    `constructor(private module: NativeInterface = NativeModule) {}`
  );
  writer.blankLn();

  nativeBridge.struct.value.fields
    .filter((field) => field.typeExpr.typeRef.kind === "reference")
    .forEach((field) => {
      writeTsBridges(field, writer); // write abstract bridging fields
    });

  writer.unindent();
  writer.writeLn("}");
  writer.blankLn();

  writer.writeLn(`export default new ${nativeBridge.name}(NativeModule);`);
};
